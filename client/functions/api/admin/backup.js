import {
  ensureBackupPermission,
  error,
  getDbOrError,
  json,
} from '../_utils.js';

const SYSTEM_TABLE_PREFIX = 'sqlite_';
const CLOUDFLARE_INTERNAL_PREFIX = '_cf_';
const D1_INTERNAL_PREFIX = 'd1_';
const INTERNAL_TABLES = new Set(['d1_migrations']);

const quoteIdentifier = (identifier) => {
  return `"${String(identifier).replace(/"/g, '""')}"`;
};

const escapeSqlString = (value) => {
  return String(value).replace(/'/g, "''");
};

const toSqlLiteral = (value) => {
  if (value === null || value === undefined) {
    return 'NULL';
  }

  if (typeof value === 'number') {
    return Number.isFinite(value) ? String(value) : 'NULL';
  }

  if (typeof value === 'boolean') {
    return value ? '1' : '0';
  }

  if (value instanceof Date) {
    return `'${escapeSqlString(value.toISOString())}'`;
  }

  if (value instanceof Uint8Array) {
    const hex = Array.from(value)
      .map((byte) => byte.toString(16).padStart(2, '0'))
      .join('');
    return `X'${hex}'`;
  }

  if (value instanceof ArrayBuffer) {
    return toSqlLiteral(new Uint8Array(value));
  }

  if (typeof value === 'object') {
    const serialized = JSON.stringify(value);
    if (serialized === undefined) {
      return 'NULL';
    }
    return `'${escapeSqlString(serialized)}'`;
  }

  return `'${escapeSqlString(value)}'`;
};

const getBackupFileName = () => {
  const iso = new Date().toISOString().replace(/[-:]/g, '').replace(/\.\d{3}Z$/, 'Z');
  return `dishhub-backup-${iso}.sql`;
};

const shouldSkipTable = (tableName) => {
  return (
    tableName.startsWith(SYSTEM_TABLE_PREFIX) ||
    tableName.startsWith(CLOUDFLARE_INTERNAL_PREFIX) ||
    tableName.startsWith(D1_INTERNAL_PREFIX) ||
    INTERNAL_TABLES.has(tableName)
  );
};

const readSchema = async (db) => {
  const tableSql = `
    SELECT name, sql
    FROM sqlite_master
    WHERE type = 'table' AND sql IS NOT NULL
    ORDER BY name ASC
  `;
  const indexSql = `
    SELECT name, sql, tbl_name
    FROM sqlite_master
    WHERE type = 'index' AND sql IS NOT NULL
    ORDER BY name ASC
  `;

  const [{ results: tableRows }, { results: indexRows }] = await Promise.all([
    db.prepare(tableSql).all(),
    db.prepare(indexSql).all(),
  ]);

  const tables = (tableRows || []).filter((row) => !shouldSkipTable(String(row.name || '')));
  const indexes = (indexRows || []).filter((row) => !shouldSkipTable(String(row.tbl_name || '')));

  return { tables, indexes };
};

const readTableRows = async (db, tableName) => {
  const query = `SELECT * FROM ${quoteIdentifier(tableName)}`;
  const { results } = await db.prepare(query).all();
  return results || [];
};

const buildInsertStatements = (tableName, rows) => {
  if (rows.length === 0) {
    return [];
  }

  const firstRow = rows[0];
  const columns = Object.keys(firstRow);
  const quotedColumns = columns.map(quoteIdentifier).join(', ');
  const table = quoteIdentifier(tableName);

  return rows.map((row) => {
    const values = columns.map((column) => toSqlLiteral(row[column])).join(', ');
    return `INSERT INTO ${table} (${quotedColumns}) VALUES (${values});`;
  });
};

const createSqlDump = async (db) => {
  const { tables, indexes } = await readSchema(db);
  const lines = [];
  const tableCount = tables.length;
  let totalRows = 0;

  lines.push('-- DishHub D1 backup (generated by /api/admin/backup)');
  lines.push(`-- Generated at: ${new Date().toISOString()}`);
  lines.push('PRAGMA foreign_keys=OFF;');
  lines.push('BEGIN TRANSACTION;');
  lines.push('');

  for (const table of tables) {
    lines.push(`-- Schema: ${table.name}`);
    lines.push(`${String(table.sql).trim()};`);
    lines.push('');
  }

  for (const table of tables) {
    const tableName = String(table.name);
    const rows = await readTableRows(db, tableName);
    totalRows += rows.length;

    lines.push(`-- Data: ${tableName} (${rows.length} rows)`);
    if (rows.length > 0) {
      const inserts = buildInsertStatements(tableName, rows);
      lines.push(...inserts);
    }
    lines.push('');
  }

  for (const index of indexes) {
    lines.push(`-- Index: ${index.name}`);
    lines.push(`${String(index.sql).trim()};`);
    lines.push('');
  }

  lines.push('COMMIT;');
  lines.push('PRAGMA foreign_keys=ON;');

  return {
    sql: lines.join('\n'),
    tableCount,
    totalRows,
  };
};

export async function onRequestGet(context) {
  const { env, request } = context;

  const permissionResponse = ensureBackupPermission(env, request);
  if (permissionResponse) {
    return permissionResponse;
  }

  const { db, response } = getDbOrError(env);
  if (response) {
    return response;
  }

  try {
    const url = new URL(request.url);
    const format = (url.searchParams.get('format') || 'sql').toLowerCase();

    const dump = await createSqlDump(db);

    if (format === 'json') {
      return json({
        generated_at: new Date().toISOString(),
        table_count: dump.tableCount,
        total_rows: dump.totalRows,
        sql: dump.sql,
      });
    }

    return new Response(dump.sql, {
      status: 200,
      headers: {
        'content-type': 'application/sql; charset=utf-8',
        'content-disposition': `attachment; filename="${getBackupFileName()}"`,
      },
    });
  } catch (cause) {
    return error('导出备份失败', 500, 'ADMIN_BACKUP_EXPORT_FAILED', {
      cause: String(cause?.message || cause),
    });
  }
}
